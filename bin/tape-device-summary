#!/usr/bin/env raku

use Async::Command::Multi;
use Our::Cache;
use Getopt::Long;
use Our::Grid;
use Our::Grid::Cell;
use JSON::Fast;
use Our::Utilities;

use Data::Dump::Tree;
#use Grammar::Debugger;

my %command;
my %results;
my %servers;

my class FCS-Device {
    has Str             $.physical-location;
    has Str             $.world-wide-node-name;
    has Str             $.world-wide-port-name;
    has                 @!drives;
}

grammar FCS-grammar {
    token TOP {
        ^
        <fcs-record>+
    }
    token fcs-record {
        \s+ <fcs-device> \s+  
        .+?
        Network \s Address '.'+ <network-address>
        .+?
        Device \s Specific.\(Z8\) '.'+ <Z8>
        .+?
        Hardware \s Location \s Code '.'+ <hardware-location>
        .+?
    }
    token fcs-device        { fcs <fcs-number>                      }
    token fcs-number        { \d+                                   }
    token network-address   { <[0..9A..F]> ** 16                    }
    token Z8                { <[0..9A..F]> ** 16                    }
    token hardware-location { \w+ '.' \w+ '.' <[0..9A..F]>+ .+? $$  }
}

class FCS-actions {
    has $.server  is required;

    method fcs-record ($/) {
        my Int $fcs-number = +$/<fcs-device><fcs-number>;
        %servers{$!server}<FCS>[$fcs-number] = FCS-Device.new:
            :physical-location(~$/<hardware-location>),
            :world-wide-node-name(~$/<Z8>),
            :world-wide-port-name(~$/<network-address>
        );
    }
}

my class RMT-Device {
    has Str             $.physical-location;
    has Str             $.host-model;
    has Str             $.host-type;
    has Str             $.host-serial;
    has Str             $.vadapter;
    has Str             $.vslot;
    has Str             $.vport;
    has Str             $.target-WWN;
    has Str             $.target-LUN;
    has Str             $.device-model;
    has Str             $.device-type;
    has Str             $.serial-number;
    has Str             $.firmware;
    has                 $!smc;
    method smc ($smc?) {
        $!smc           = $smc  if $smc;
        return $!smc;
    }
}

grammar RMT-grammar {
    token TOP {
        ^
        <rmt-record>+
    }
    token rmt-record {
        \s+ <rmt-device> \s+
        <physical-location>
        '-'
        <target>
        .+?
        Machine \s Type \s and \s Model '.'+ <drive-type-model>
        .+?
        Serial \s Number '.'+ <serial-number>
        .+?
        Device \s Specific '.' \(FW\) '.'+ <firmware>
        $$
    }
    token rmt-device        { rmt <rmt-number>                      }
    token rmt-number        { \d+                                   }
    token physical-location {
        <host-model>
        '.'
        <host-type>
        '.'
        <host-serial>
        '-'
        <vadapter>
        '-'
        <vslot>
        '-'
        <vport>
    }
    token host-model        { \w+                                   }
    token host-type         { \w+                                   }
    token host-serial       { \w+                                   }
    token vadapter          { \w+                                   }
    token vslot             { C \w+                                 }
    token vport             { T \w+                                 }
    token target            { <target-WWN> '-' <target-LUN>         }
    token target-WWN        { W <[0..9A..F]> ** 16                  }
    token target-LUN        { L \w+                                 }
    token drive-type-model  { <device-model> '-' <device-type>      }
    token device-model      { \w+                                   }
    token device-type       { \w+                                   }
    token serial-number     { \w+                                   }
    token firmware          { \w+                                   }
}

class RMT-actions {
    has $.server  is required;

    method rmt-record ($/) {
        my Int $rmt-number = +$/<rmt-device><rmt-number>;
        %servers{$!server}<RMT>[$rmt-number] = RMT-Device.new:
            :physical-location(~$/<physical-location>),
            :host-model(~$/<physical-location><host-model>),
            :host-type(~$/<physical-location><host-type>),
            :host-serial(~$/<physical-location><host-serial>),
            :vadapter(~$/<physical-location><vadapter>),
            :vslot(~$/<physical-location><vslot>),
            :vport(~$/<physical-location><vport>),
            :target-WWN(~$/<target><target-WWN>),
            :target-LUN(~$/<target><target-LUN>),
            :device-model(~$/<drive-type-model><device-model>),
            :device-type(~$/<drive-type-model><device-type>),
            :serial-number(~$/<serial-number>),
            :firmware(~$/<firmware>),
        ;
    }
}

my class SMC-Device {
    has Str             $.physical-location;
    has Str             $.host-model;
    has Str             $.host-type;
    has Str             $.host-serial;
    has Str             $.vadapter;
    has Str             $.vslot;
    has Str             $.vport;
    has Str             $.target-WWN;
    has Str             $.target-LUN;
    has Str             $.device-type-model;
    has Str             $.serial-number;
    has Str             $.firmware;
    has                 $!rmt;
    method rmt ($rmt?) {
        $!rmt           = $rmt  if $rmt;
        return $!rmt;
    }
}

grammar SMC-grammar {
    token TOP {
        ^
        <smc-record>+
    }
    token smc-record {
        \s+ <smc-device> \s+
        <physical-location>
        '-'
        <target>
        .+?
        Machine \s Type \s and \s Model '.'+ <drive-type-model>
        .+?
        Serial \s Number '.'+ <serial-number>
        .+?
        Device \s Specific '.' \(FW\) '.'+ <firmware>
        $$
    }
    token smc-device        { smc <smc-number>                      }
    token smc-number        { \d+                                   }
    token physical-location {
        <host-model>
        '.'
        <host-type>
        '.'
        <host-serial>
        '-'
        <vadapter>
        '-'
        <vslot>
        '-'
        <vport>
    }
    token host-model        { \w+                                   }
    token host-type         { \w+                                   }
    token host-serial       { \w+                                   }
    token vadapter          { \w+                                   }
    token vslot             { C \w+                                 }
    token vport             { T \w+                                 }
    token target            { <target-WWN> '-' <target-LUN>         }
    token target-WWN        { W <[0..9A..F]> ** 16                  }
    token target-LUN        { L \w+                                 }
    token drive-type-model  { .+?                                $$ }
    token serial-number     { \w+                                   }
    token firmware          { \w+                                   }
}

class SMC-actions {
    has $.server  is required;

    method smc-record ($/) {
        my Int $smc-number = +$/<smc-device><smc-number>;
        %servers{$!server}<SMC>[$smc-number] = SMC-Device.new:
            :physical-location(~$/<physical-location>),
            :host-model(~$/<physical-location><host-model>),
            :host-type(~$/<physical-location><host-type>),
            :host-serial(~$/<physical-location><host-serial>),
            :vadapter(~$/<physical-location><vadapter>),
            :vslot(~$/<physical-location><vslot>),
            :vport(~$/<physical-location><vport>),
            :target-WWN(~$/<target><target-WWN>),
            :target-LUN(~$/<target><target-LUN>),
            :device-type-model(~$/<drive-type-model>.trim),
            :serial-number(~$/<serial-number>),
            :firmware(~$/<firmware>),
        ;
    }
}

sub MAIN (
                            :@servers            = ('isplc01','isplm01'),   #= Server to query
    Bool                    :$csv,                                          #= Dump CSV to STDOUT
    Str                     :$grid-proxy-host   = '127.0.0.1',              #= Hostname of grid proxy for remote services
    Bool                    :$gui,                                          #= Graphical User Interface
    Bool                    :$html,                                         #= Dump HTML to STDOUT
    Bool                    :$json,                                         #= Dump JSON to STDOUT
#   Grid-Email-Formats      :$mail-body-format,                             #= Email body format
                            :$mail-body-format,                             #= Email body format
                            :$mail-from,                                    #= Email 'From:' addressee
                            :@mail-to,                                      #= Accumulate email 'To:' addressees
                            :@mail-cc,                                      #= Accumulate email 'Cc:' addressees
                            :@mail-bcc,                                     #= Accumulate email 'Bcc:' addressees
    Bool                    :$text,                                         #= TEXT print
    Bool                    :$tui,                                          #= Terminal User Interface
    Bool                    :$xml,                                          #= Dump XML to STDOUT
    Bool                    :$light-mode,                                   #= Reverse header highlight for light-mode
) {
    my Bool $mailing;
    my $from                = $mail-from;
    my $format              = $mail-body-format;
    if $mail-from && @mail-to.elems {
        die '--mail-from=<email-address> required to send mail!' unless $mail-from;
        die '--mail-to=<email-address[,email-address]> required to send mail!' unless @mail-to.elems;
        $from               = $mail-from[0] if $mail-from ~~ Array;
        $format             = $mail-body-format[0] if $mail-body-format ~~ Array;
        $mailing = True;
    }
    my $reverse-highlight   = $light-mode ?? True !! False;
    my $preferences-cache   = Our::Cache.new(:identifier<preferences>);
    my $preferences         = from-json($preferences-cache.fetch) if $preferences-cache.cache-hit;
    without $light-mode {
        $reverse-highlight  = $preferences<light-mode> if $preferences<light-mode>:exists;
    }
    $preferences-cache.store(:data(to-json({light-mode => $reverse-highlight})));

    for @servers.sort -> $server {
        %command{$server}   = [
            'ssh',
            $server,
            '-o', 'BatchMode=yes',
            '-o', 'PreferredAuthentications=publickey',
            'lscfg',
            '-vl',
            'fcs*',
        ];
    }

    %results                = Async::Command::Multi.new(:%command, :10time-out, :8batch).sow.reap;
    for %results.keys.sort -> $server {
        FCS-grammar.parse(%results{$server}.stdout-results, :actions(FCS-actions.new(:$server)));
        die 'No fcs adapters found!' unless %servers{$server}<FCS>.elems;
    }

    %command                = ();
    %results                = ();

    for @servers.sort -> $server {
        %command{$server}   = [
            'ssh',
            $server,
            '-o', 'BatchMode=yes',
            '-o', 'PreferredAuthentications=publickey',
            'lscfg',
            '-vl',
            'rmt*',
        ];
    }

    %results                = Async::Command::Multi.new(:%command, :10time-out, :8batch).sow.reap;
    for %results.keys.sort -> $server {
        RMT-grammar.parse(%results{$server}.stdout-results, :actions(RMT-actions.new(:$server)));
        die 'No rmt devices found!' unless %servers{$server}<RMT>.elems;
    }

    %command                = ();
    %results                = ();

    for @servers.sort -> $server {
        %command{$server}   = [
            'ssh',
            $server,
            '-o', 'BatchMode=yes',
            '-o', 'PreferredAuthentications=publickey',
            'lscfg',
            '-vl',
            'smc*',
        ];
    }

    %results                = Async::Command::Multi.new(:%command, :10time-out, :8batch).sow.reap;
    for %results.keys.sort -> $server {
        SMC-grammar.parse(%results{$server}.stdout-results, :actions(SMC-actions.new(:$server)));
        die 'No smc devices found!' unless %servers{$server}<SMC>.elems;
    }

ddt %servers;
}
=finish

    my Our::Grid $grid;
#   if $group-by-vios {
#       $grid  .= new: :title('NPIV Summary'), :$grid-proxy-host, :$reverse-highlight, :0group-by-column;
#   }
#   else {
        $grid  .= new: :title('NPIV Summary'), :$grid-proxy-host, :$reverse-highlight;
#   }
    $grid.add-heading('VIO Server',         :justification<left>);
    $grid.add-heading('Physical Adapter',   :justification<left>);
    $grid.add-heading('Physical Location',  :justification<left>);
    $grid.add-heading('WW Node Name',       :justification<right>);
    $grid.add-heading('WW Port Name',       :justification<right>);
    $grid.add-heading('LPAR',               :justification<left>);
    $grid.add-heading('vfchost',            :justification<left>);
    $grid.add-heading('LPAR Adapter',       :justification<center>);
    $grid.add-heading('LPAR Location',      :justification<left>);
    $grid.add-heading('LPAR WW Node Name',  :justification<right>);

#   reap the deferred promises from all the selected LPARs...
    %results                = $deferred-command-manager.reap;
    for %HMC{$hmc}<managed-servers>.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        for %results.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $partition-number {
            FCS-grammar.parse(%results{$partition-number}.stdout-results, :actions(FCS-client-actions.new(:$partition-number)));
            next                if  %results{$partition-number}.exit-code;
            %HMC{$hmc}<managed-servers>{$managed-server}<lpar>{$partition-number}<fcs> = %client-results{$partition-number};
        }
    }
#ddt %HMC{$hmc};
#die;
#   9 => {1} @175
#       fcs => [4] @176
#           0 = .FCS @177
#               $.physical-location = U9080.HEX.78725A8-V9-C133-T0.Str
#               $.world-wide-node-name = C05076038EE20010.Str
#               $.world-wide-port-name = C05076038EE20010.Str
#           1 = .FCS @178
#               $.physical-location = U9080.HEX.78725A8-V9-C233-T0.Str
#               $.world-wide-node-name = C05076038EE20014.Str
#               $.world-wide-port-name = C05076038EE20014.Str


    for %HMC{$hmc}<managed-servers>.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
#       $grid.add-cell(:cell(Our::Grid::Cell.new(:text($managed-server), :bold,                                                                                         :justification<left>)), :0col);
        for %HMC{$hmc}<managed-servers>{$managed-server}<vios>.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $vio {
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($vio),                                                                                                       :justification<left>)), :0col);
            loop (my $fcs-number = 0; $fcs-number < %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<fcs>.elems; $fcs-number++) {
                next unless %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<fcs>[$fcs-number]:exists;
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text('fcs' ~ $fcs-number),                                                                                    :justification<left>)), :1col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<fcs>[$fcs-number].physical-location),           :justification<left>)), :2col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<fcs>[$fcs-number].world-wide-node-name),        :justification<left>)), :3col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<fcs>[$fcs-number].world-wide-port-name),        :justification<left>)), :4col);
                for %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<viopadaptername2vfchost>{'fcs' ~ $fcs-number}.list -> $vfchost {
                    next unless $vfchost;
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text($vfchost),                                                                                           :justification<left>)), :5col);
                    if %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.lpar-name {
                        $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.lpar-name),             :justification<left>)), :6col);
                    }
                    else {
                        $grid.add-cell(:cell(Our::Grid::Cell.new(:text(''),                                                                                             :justification<left>)), :6col);
                    }
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.client-fcs-device),         :justification<left>)), :7col);
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.client-vadapter-location),  :justification<left>)), :8col);


                    my $client-adapter-world-wide-node-name = '';
                    my $lpar-id                             = %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.lpar-id;
                    my $client-adapter                      = %HMC{$hmc}<managed-servers>{$managed-server}<vios>{$vio}<npiv>{$vfchost}.client-fcs-device;
                    my $client-adapter-number               = $client-adapter.subst('fcs');
                    if %HMC{$hmc}<managed-servers>{$managed-server}<lpar>{$lpar-id}<fcs>[$client-adapter-number]:exists {
                        $client-adapter-world-wide-node-name    = %HMC{$hmc}<managed-servers>{$managed-server}<lpar>{$lpar-id}<fcs>[$client-adapter-number].world-wide-node-name;
                    }
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text($client-adapter-world-wide-node-name),                                                               :justification<left>)), :9col);
                    $grid.current-row++;
                }
            }
        }
    }
    {
        when $text          {   $grid.TEXT-print; }
        when $html          {   $grid.HTML-print; }
        when $csv           {   $grid.CSV-print;  }
        when $json          {   $grid.JSON-print; }
        when $mailing       {
                                $grid.send-proxy-mail-via-redis(
                                    :cro-host<127.0.0.1>,
                                    :22151cro-port,
                                    :mail-from($from),
                                    :@mail-to,
                                    :@mail-cc,
                                    :@mail-bcc,
                                    :$format,
                                );
        }
        when $xml           {   $grid.XML-print;  }
        when $tui           {   $grid.TUI;        }
        when $gui           {   $grid.GUI;        }
        default             {   $grid.ANSI-print; }
    }
}

=finish
